

В Go какие есть примитивные типы данных:
1) числа
    1.2) целые - int (64 бит, 32 бит, зависит от архитектуры процессора), int64, int32... uint (...)
    1.3) с плавающей точкой - float32, float64 | вопрос: как храним деньги в коде? - например в храним в копейках в int'ах

2) строки - неизменяемые в Go

    hello := "hello"
    for i := 0; i < len(hello); i++ { // это побайтовый обход строки
        print(hello[i])
    }

    hello := "hello"
    for _, v := range hello { // это порунный обход строки
        print(v)
    }

    len(hello) // выведет длину чего (байт или символов)?
    выведет длину символов

3) булевы - 1 байт | он изменяймый

4) указатели - что это?
func main() {
    count := 0
    change1(count)
    print(count) // что выведет - 0
    change2(&count)
    print(count) // что выведет - 2
}

func change1(c int) {
    c = 1
}

func change2(c *int) {
    *c = 2
}

[
  0x1234324324[2]
     ]

Массивы в Go:

// Массив - упорядоченный тип данных
a := [5]int{1,2,3,4,5}

m := 5

q := 6
[[][][][]   [m]

    [a_____]
 [p]    [q]

                   ]

Операции над массивами: чтение по индексу/запись по индексу за O(1)

Слайсы в Go:

// Динамический массив - это значит, что он может изменять свой размер
a := []int{1,2,3,4,5}

// Так он выглядит под капотом
{
    *arr &0x1342432
    len  5,
    cap  5,
}

Операции над слайсами: чтение по индексу/запись по индексу за O(1)

a := make([]int, 5, 10)

{
    *arr &0x1342432
    len  11,
    cap  20,
}

[[][][][]   [m]

    [a012345|678910]
 [p]    [q]
    [a012345|67891011_______________] // перевыделится новый базовый массив и cap увеличится в 2 раза
                   ]

a = append(a, 6)
a = append(a, 7)
a = append(a, 8)
a = append(a, 9)
a = append(a, 10)

a = append(a, 11) - O(N)

Задачки на слайсы:

func main() {
    var sl []int
    fmt.Println(sl) // []

    sl = append(sl, 1)
    fmt.Println(sl) // [1]
    fmt.Println("len =", len(sl), "cap =", cap(sl)) // что выведет // [1,1]

    sl = append(sl, 2)
    fmt.Println(sl) // [1,2]
    fmt.Println("len =", len(sl), "cap =", cap(sl)) // что выведет // [2,2]

    sl_a := append(sl, 3)
    fmt.Println("len =", len(sl_a), "cap =", cap(sl_a)) // что выведет // [3,4]
    fmt.Println("sl_a", sl_a) // что выведет // [1,2,3]
    fmt.Println("sl", sl) // что выведет // [1,2]

    sl_a[0] = 5
    fmt.Println("sl", sl)     // что выведет // [1,2]
    fmt.Println("sl_a", sl_a) // что выведет // [5,2,3]

    sl_b := append(sl_a, 4)
    fmt.Println(sl_b) // что выведет // [5,2,3,4]
    // [5,2,3] [len=3, cap=4]
    // [5,2,3,4] [len=4, cap=4]
    sl_b[1] = 6
    fmt.Println("sl_a", sl_a) // что выведет // [5,6,3]
    fmt.Println("sl_b", sl_b) // что выведет // [5,6,3,4]
}



