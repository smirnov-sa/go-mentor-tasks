package main

import "fmt"

func main() {
	s := []int{1, 2, 3, 4, 5}
	fmt.Println(s)

	s = append(s, 6) // Добавлили элемент, вместимость не изменилась.
	fmt.Println("длина =", len(s), "вместимость =", cap(s))

	s = append(s, 7, 7, 7, 7, 7) // Добавлили 5 элементов, вместимость увеличилась в 2 раза. Создался новый слайс, который ссылается на новую ячейку в памяти.
	fmt.Println("длина =", len(s), "вместимость =", cap(s))

	s2 := make([]int, len(s), cap(s)) // Длина будет 11, а вместимость 20 т.к. мы опираемся на ту же самую ячейку памяти.
	fmt.Println(s2)
	fmt.Println("длина =", len(s), "вместимость =", cap(s))

	s3 := make([]int, 5, 500) // Создадим слайс и зададим длину и вместимость.
	fmt.Println(s3)
	fmt.Println("длина =", len(s), "вместимость =", cap(s))

	s4 := s[1:3] // Выведет элемементы массива с 1 по 2, последний не возьмет.
	fmt.Println(s4)

	s4 = s[1:] // Выведет элемементы массива с 1 по последний.
	fmt.Println(s4)

	s5 := s[0:2:2] // Возьмем слайс из слайса с заданной длиной и вместимостью.
	fmt.Println(s5)

	s6 := []int{1, 2, 3, 4, 5}
	s7 := s6[0:2] // Если [0:2], то 444 уйдет с слайс s6. Тот же самый указатель памяти, что и в s6. Если [0:2:2], мы ограничиваем вместимость массива и append создает копию с новым указателем. 444 будет только в слайсе s7.
	s7 = append(s7, 444)
	fmt.Println(s6)
	fmt.Println(s7)
	fmt.Println("длина =", len(s6), "вместимость =", cap(s6))
	fmt.Println("длина =", len(s7), "вместимость =", cap(s7))

}
